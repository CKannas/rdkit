// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Mol.proto

#ifndef PROTOBUF_Mol_2eproto__INCLUDED
#define PROTOBUF_Mol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace RDKit {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Mol_2eproto();
void protobuf_AssignDesc_Mol_2eproto();
void protobuf_ShutdownFile_Mol_2eproto();

class pbAtom;
class pbBond;
class pbUIntVect;
class pbRingInfo;
class pbPoint3D;
class pbConformer;
class pbQuery;
class pbMol;

// ===================================================================

class pbAtom : public ::google::protobuf::Message {
 public:
  pbAtom();
  virtual ~pbAtom();
  
  pbAtom(const pbAtom& from);
  
  inline pbAtom& operator=(const pbAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbAtom& default_instance();
  
  void Swap(pbAtom* other);
  
  // implements Message ----------------------------------------------
  
  pbAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbAtom& from);
  void MergeFrom(const pbAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 atomicNum = 1 [default = 6];
  inline bool has_atomicnum() const;
  inline void clear_atomicnum();
  static const int kAtomicNumFieldNumber = 1;
  inline ::google::protobuf::uint32 atomicnum() const;
  inline void set_atomicnum(::google::protobuf::uint32 value);
  
  // optional bool aromatic = 20;
  inline bool has_aromatic() const;
  inline void clear_aromatic();
  static const int kAromaticFieldNumber = 20;
  inline bool aromatic() const;
  inline void set_aromatic(bool value);
  
  // optional bool noimplicit = 21;
  inline bool has_noimplicit() const;
  inline void clear_noimplicit();
  static const int kNoimplicitFieldNumber = 21;
  inline bool noimplicit() const;
  inline void set_noimplicit(bool value);
  
  // optional float mass = 100;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 100;
  inline float mass() const;
  inline void set_mass(float value);
  
  // optional sint32 charge = 101;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 101;
  inline ::google::protobuf::int32 charge() const;
  inline void set_charge(::google::protobuf::int32 value);
  
  // optional int32 chiraltag = 102;
  inline bool has_chiraltag() const;
  inline void clear_chiraltag();
  static const int kChiraltagFieldNumber = 102;
  inline ::google::protobuf::int32 chiraltag() const;
  inline void set_chiraltag(::google::protobuf::int32 value);
  
  // optional int32 hybridization = 103 [default = 4];
  inline bool has_hybridization() const;
  inline void clear_hybridization();
  static const int kHybridizationFieldNumber = 103;
  inline ::google::protobuf::int32 hybridization() const;
  inline void set_hybridization(::google::protobuf::int32 value);
  
  // optional int32 numexpliciths = 104;
  inline bool has_numexpliciths() const;
  inline void clear_numexpliciths();
  static const int kNumexplicithsFieldNumber = 104;
  inline ::google::protobuf::int32 numexpliciths() const;
  inline void set_numexpliciths(::google::protobuf::int32 value);
  
  // optional int32 explicitvalence = 105;
  inline bool has_explicitvalence() const;
  inline void clear_explicitvalence();
  static const int kExplicitvalenceFieldNumber = 105;
  inline ::google::protobuf::int32 explicitvalence() const;
  inline void set_explicitvalence(::google::protobuf::int32 value);
  
  // optional int32 implicitvalence = 106;
  inline bool has_implicitvalence() const;
  inline void clear_implicitvalence();
  static const int kImplicitvalenceFieldNumber = 106;
  inline ::google::protobuf::int32 implicitvalence() const;
  inline void set_implicitvalence(::google::protobuf::int32 value);
  
  // optional int32 numradicalelectrons = 107;
  inline bool has_numradicalelectrons() const;
  inline void clear_numradicalelectrons();
  static const int kNumradicalelectronsFieldNumber = 107;
  inline ::google::protobuf::int32 numradicalelectrons() const;
  inline void set_numradicalelectrons(::google::protobuf::int32 value);
  
  // optional bool hasatommapnumber = 108;
  inline bool has_hasatommapnumber() const;
  inline void clear_hasatommapnumber();
  static const int kHasatommapnumberFieldNumber = 108;
  inline bool hasatommapnumber() const;
  inline void set_hasatommapnumber(bool value);
  
  // optional int32 molatommapnumber = 109;
  inline bool has_molatommapnumber() const;
  inline void clear_molatommapnumber();
  static const int kMolatommapnumberFieldNumber = 109;
  inline ::google::protobuf::int32 molatommapnumber() const;
  inline void set_molatommapnumber(::google::protobuf::int32 value);
  
  // optional bool hasquery = 200;
  inline bool has_hasquery() const;
  inline void clear_hasquery();
  static const int kHasqueryFieldNumber = 200;
  inline bool hasquery() const;
  inline void set_hasquery(bool value);
  
  // optional .RDKit.pbQuery query = 201;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 201;
  inline const ::RDKit::pbQuery& query() const;
  inline ::RDKit::pbQuery* mutable_query();
  inline ::RDKit::pbQuery* release_query();
  
  // @@protoc_insertion_point(class_scope:RDKit.pbAtom)
 private:
  inline void set_has_atomicnum();
  inline void clear_has_atomicnum();
  inline void set_has_aromatic();
  inline void clear_has_aromatic();
  inline void set_has_noimplicit();
  inline void clear_has_noimplicit();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_chiraltag();
  inline void clear_has_chiraltag();
  inline void set_has_hybridization();
  inline void clear_has_hybridization();
  inline void set_has_numexpliciths();
  inline void clear_has_numexpliciths();
  inline void set_has_explicitvalence();
  inline void clear_has_explicitvalence();
  inline void set_has_implicitvalence();
  inline void clear_has_implicitvalence();
  inline void set_has_numradicalelectrons();
  inline void clear_has_numradicalelectrons();
  inline void set_has_hasatommapnumber();
  inline void clear_has_hasatommapnumber();
  inline void set_has_molatommapnumber();
  inline void clear_has_molatommapnumber();
  inline void set_has_hasquery();
  inline void clear_has_hasquery();
  inline void set_has_query();
  inline void clear_has_query();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 atomicnum_;
  float mass_;
  ::google::protobuf::int32 charge_;
  ::google::protobuf::int32 chiraltag_;
  ::google::protobuf::int32 hybridization_;
  bool aromatic_;
  bool noimplicit_;
  bool hasatommapnumber_;
  bool hasquery_;
  ::google::protobuf::int32 numexpliciths_;
  ::google::protobuf::int32 explicitvalence_;
  ::google::protobuf::int32 implicitvalence_;
  ::google::protobuf::int32 numradicalelectrons_;
  ::RDKit::pbQuery* query_;
  ::google::protobuf::int32 molatommapnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbAtom* default_instance_;
};
// -------------------------------------------------------------------

class pbBond : public ::google::protobuf::Message {
 public:
  pbBond();
  virtual ~pbBond();
  
  pbBond(const pbBond& from);
  
  inline pbBond& operator=(const pbBond& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbBond& default_instance();
  
  void Swap(pbBond* other);
  
  // implements Message ----------------------------------------------
  
  pbBond* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbBond& from);
  void MergeFrom(const pbBond& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 beginatom = 1;
  inline bool has_beginatom() const;
  inline void clear_beginatom();
  static const int kBeginatomFieldNumber = 1;
  inline ::google::protobuf::uint32 beginatom() const;
  inline void set_beginatom(::google::protobuf::uint32 value);
  
  // required uint32 endatom = 2;
  inline bool has_endatom() const;
  inline void clear_endatom();
  static const int kEndatomFieldNumber = 2;
  inline ::google::protobuf::uint32 endatom() const;
  inline void set_endatom(::google::protobuf::uint32 value);
  
  // optional bool aromatic = 20;
  inline bool has_aromatic() const;
  inline void clear_aromatic();
  static const int kAromaticFieldNumber = 20;
  inline bool aromatic() const;
  inline void set_aromatic(bool value);
  
  // optional bool conjugated = 21;
  inline bool has_conjugated() const;
  inline void clear_conjugated();
  static const int kConjugatedFieldNumber = 21;
  inline bool conjugated() const;
  inline void set_conjugated(bool value);
  
  // optional uint32 type = 102 [default = 1];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 102;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 dir = 103;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 103;
  inline ::google::protobuf::uint32 dir() const;
  inline void set_dir(::google::protobuf::uint32 value);
  
  // optional uint32 stereo = 104;
  inline bool has_stereo() const;
  inline void clear_stereo();
  static const int kStereoFieldNumber = 104;
  inline ::google::protobuf::uint32 stereo() const;
  inline void set_stereo(::google::protobuf::uint32 value);
  
  // repeated uint32 stereoatom = 105;
  inline int stereoatom_size() const;
  inline void clear_stereoatom();
  static const int kStereoatomFieldNumber = 105;
  inline ::google::protobuf::uint32 stereoatom(int index) const;
  inline void set_stereoatom(int index, ::google::protobuf::uint32 value);
  inline void add_stereoatom(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      stereoatom() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_stereoatom();
  
  // optional bool hasquery = 200;
  inline bool has_hasquery() const;
  inline void clear_hasquery();
  static const int kHasqueryFieldNumber = 200;
  inline bool hasquery() const;
  inline void set_hasquery(bool value);
  
  // optional .RDKit.pbQuery query = 201;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 201;
  inline const ::RDKit::pbQuery& query() const;
  inline ::RDKit::pbQuery* mutable_query();
  inline ::RDKit::pbQuery* release_query();
  
  // @@protoc_insertion_point(class_scope:RDKit.pbBond)
 private:
  inline void set_has_beginatom();
  inline void clear_has_beginatom();
  inline void set_has_endatom();
  inline void clear_has_endatom();
  inline void set_has_aromatic();
  inline void clear_has_aromatic();
  inline void set_has_conjugated();
  inline void clear_has_conjugated();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_stereo();
  inline void clear_has_stereo();
  inline void set_has_hasquery();
  inline void clear_has_hasquery();
  inline void set_has_query();
  inline void clear_has_query();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 beginatom_;
  ::google::protobuf::uint32 endatom_;
  ::google::protobuf::uint32 type_;
  bool aromatic_;
  bool conjugated_;
  bool hasquery_;
  ::google::protobuf::uint32 dir_;
  ::google::protobuf::uint32 stereo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > stereoatom_;
  ::RDKit::pbQuery* query_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbBond* default_instance_;
};
// -------------------------------------------------------------------

class pbUIntVect : public ::google::protobuf::Message {
 public:
  pbUIntVect();
  virtual ~pbUIntVect();
  
  pbUIntVect(const pbUIntVect& from);
  
  inline pbUIntVect& operator=(const pbUIntVect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbUIntVect& default_instance();
  
  void Swap(pbUIntVect* other);
  
  // implements Message ----------------------------------------------
  
  pbUIntVect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbUIntVect& from);
  void MergeFrom(const pbUIntVect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 val = 1;
  inline int val_size() const;
  inline void clear_val();
  static const int kValFieldNumber = 1;
  inline ::google::protobuf::uint32 val(int index) const;
  inline void set_val(int index, ::google::protobuf::uint32 value);
  inline void add_val(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      val() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_val();
  
  // @@protoc_insertion_point(class_scope:RDKit.pbUIntVect)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > val_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbUIntVect* default_instance_;
};
// -------------------------------------------------------------------

class pbRingInfo : public ::google::protobuf::Message {
 public:
  pbRingInfo();
  virtual ~pbRingInfo();
  
  pbRingInfo(const pbRingInfo& from);
  
  inline pbRingInfo& operator=(const pbRingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbRingInfo& default_instance();
  
  void Swap(pbRingInfo* other);
  
  // implements Message ----------------------------------------------
  
  pbRingInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbRingInfo& from);
  void MergeFrom(const pbRingInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .RDKit.pbUIntVect bondring = 1;
  inline int bondring_size() const;
  inline void clear_bondring();
  static const int kBondringFieldNumber = 1;
  inline const ::RDKit::pbUIntVect& bondring(int index) const;
  inline ::RDKit::pbUIntVect* mutable_bondring(int index);
  inline ::RDKit::pbUIntVect* add_bondring();
  inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >&
      bondring() const;
  inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >*
      mutable_bondring();
  
  // repeated .RDKit.pbUIntVect atomring = 2;
  inline int atomring_size() const;
  inline void clear_atomring();
  static const int kAtomringFieldNumber = 2;
  inline const ::RDKit::pbUIntVect& atomring(int index) const;
  inline ::RDKit::pbUIntVect* mutable_atomring(int index);
  inline ::RDKit::pbUIntVect* add_atomring();
  inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >&
      atomring() const;
  inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >*
      mutable_atomring();
  
  // @@protoc_insertion_point(class_scope:RDKit.pbRingInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect > bondring_;
  ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect > atomring_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbRingInfo* default_instance_;
};
// -------------------------------------------------------------------

class pbPoint3D : public ::google::protobuf::Message {
 public:
  pbPoint3D();
  virtual ~pbPoint3D();
  
  pbPoint3D(const pbPoint3D& from);
  
  inline pbPoint3D& operator=(const pbPoint3D& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbPoint3D& default_instance();
  
  void Swap(pbPoint3D* other);
  
  // implements Message ----------------------------------------------
  
  pbPoint3D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbPoint3D& from);
  void MergeFrom(const pbPoint3D& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // @@protoc_insertion_point(class_scope:RDKit.pbPoint3D)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbPoint3D* default_instance_;
};
// -------------------------------------------------------------------

class pbConformer : public ::google::protobuf::Message {
 public:
  pbConformer();
  virtual ~pbConformer();
  
  pbConformer(const pbConformer& from);
  
  inline pbConformer& operator=(const pbConformer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbConformer& default_instance();
  
  void Swap(pbConformer* other);
  
  // implements Message ----------------------------------------------
  
  pbConformer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbConformer& from);
  void MergeFrom(const pbConformer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional bool is3d = 2;
  inline bool has_is3d() const;
  inline void clear_is3d();
  static const int kIs3DFieldNumber = 2;
  inline bool is3d() const;
  inline void set_is3d(bool value);
  
  // repeated .RDKit.pbPoint3D position = 3;
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::RDKit::pbPoint3D& position(int index) const;
  inline ::RDKit::pbPoint3D* mutable_position(int index);
  inline ::RDKit::pbPoint3D* add_position();
  inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbPoint3D >&
      position() const;
  inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbPoint3D >*
      mutable_position();
  
  // @@protoc_insertion_point(class_scope:RDKit.pbConformer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_is3d();
  inline void clear_has_is3d();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  bool is3d_;
  ::google::protobuf::RepeatedPtrField< ::RDKit::pbPoint3D > position_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbConformer* default_instance_;
};
// -------------------------------------------------------------------

class pbQuery : public ::google::protobuf::Message {
 public:
  pbQuery();
  virtual ~pbQuery();
  
  pbQuery(const pbQuery& from);
  
  inline pbQuery& operator=(const pbQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbQuery& default_instance();
  
  void Swap(pbQuery* other);
  
  // implements Message ----------------------------------------------
  
  pbQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbQuery& from);
  void MergeFrom(const pbQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // required string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional bool negation = 3;
  inline bool has_negation() const;
  inline void clear_negation();
  static const int kNegationFieldNumber = 3;
  inline bool negation() const;
  inline void set_negation(bool value);
  
  // repeated sint32 intvalue = 20;
  inline int intvalue_size() const;
  inline void clear_intvalue();
  static const int kIntvalueFieldNumber = 20;
  inline ::google::protobuf::int32 intvalue(int index) const;
  inline void set_intvalue(int index, ::google::protobuf::int32 value);
  inline void add_intvalue(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intvalue() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intvalue();
  
  // optional sint32 inttol = 21;
  inline bool has_inttol() const;
  inline void clear_inttol();
  static const int kInttolFieldNumber = 21;
  inline ::google::protobuf::int32 inttol() const;
  inline void set_inttol(::google::protobuf::int32 value);
  
  // optional sint32 intbegin = 22;
  inline bool has_intbegin() const;
  inline void clear_intbegin();
  static const int kIntbeginFieldNumber = 22;
  inline ::google::protobuf::int32 intbegin() const;
  inline void set_intbegin(::google::protobuf::int32 value);
  
  // optional sint32 intend = 23;
  inline bool has_intend() const;
  inline void clear_intend();
  static const int kIntendFieldNumber = 23;
  inline ::google::protobuf::int32 intend() const;
  inline void set_intend(::google::protobuf::int32 value);
  
  // optional bool openbegin = 24;
  inline bool has_openbegin() const;
  inline void clear_openbegin();
  static const int kOpenbeginFieldNumber = 24;
  inline bool openbegin() const;
  inline void set_openbegin(bool value);
  
  // optional bool openend = 25;
  inline bool has_openend() const;
  inline void clear_openend();
  static const int kOpenendFieldNumber = 25;
  inline bool openend() const;
  inline void set_openend(bool value);
  
  // optional .RDKit.pbMol molvalue = 26;
  inline bool has_molvalue() const;
  inline void clear_molvalue();
  static const int kMolvalueFieldNumber = 26;
  inline const ::RDKit::pbMol& molvalue() const;
  inline ::RDKit::pbMol* mutable_molvalue();
  inline ::RDKit::pbMol* release_molvalue();
  
  // repeated .RDKit.pbQuery child = 5;
  inline int child_size() const;
  inline void clear_child();
  static const int kChildFieldNumber = 5;
  inline const ::RDKit::pbQuery& child(int index) const;
  inline ::RDKit::pbQuery* mutable_child(int index);
  inline ::RDKit::pbQuery* add_child();
  inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbQuery >&
      child() const;
  inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbQuery >*
      mutable_child();
  
  // @@protoc_insertion_point(class_scope:RDKit.pbQuery)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_negation();
  inline void clear_has_negation();
  inline void set_has_inttol();
  inline void clear_has_inttol();
  inline void set_has_intbegin();
  inline void clear_has_intbegin();
  inline void set_has_intend();
  inline void clear_has_intend();
  inline void set_has_openbegin();
  inline void clear_has_openbegin();
  inline void set_has_openend();
  inline void clear_has_openend();
  inline void set_has_molvalue();
  inline void clear_has_molvalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* description_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::int32 inttol_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intvalue_;
  ::google::protobuf::int32 intbegin_;
  bool negation_;
  bool openbegin_;
  bool openend_;
  ::RDKit::pbMol* molvalue_;
  ::google::protobuf::RepeatedPtrField< ::RDKit::pbQuery > child_;
  ::google::protobuf::int32 intend_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbQuery* default_instance_;
};
// -------------------------------------------------------------------

class pbMol : public ::google::protobuf::Message {
 public:
  pbMol();
  virtual ~pbMol();
  
  pbMol(const pbMol& from);
  
  inline pbMol& operator=(const pbMol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbMol& default_instance();
  
  void Swap(pbMol* other);
  
  // implements Message ----------------------------------------------
  
  pbMol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbMol& from);
  void MergeFrom(const pbMol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .RDKit.pbAtom atom = 1;
  inline int atom_size() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 1;
  inline const ::RDKit::pbAtom& atom(int index) const;
  inline ::RDKit::pbAtom* mutable_atom(int index);
  inline ::RDKit::pbAtom* add_atom();
  inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbAtom >&
      atom() const;
  inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbAtom >*
      mutable_atom();
  
  // repeated .RDKit.pbBond bond = 2;
  inline int bond_size() const;
  inline void clear_bond();
  static const int kBondFieldNumber = 2;
  inline const ::RDKit::pbBond& bond(int index) const;
  inline ::RDKit::pbBond* mutable_bond(int index);
  inline ::RDKit::pbBond* add_bond();
  inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbBond >&
      bond() const;
  inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbBond >*
      mutable_bond();
  
  // optional .RDKit.pbRingInfo rings = 100;
  inline bool has_rings() const;
  inline void clear_rings();
  static const int kRingsFieldNumber = 100;
  inline const ::RDKit::pbRingInfo& rings() const;
  inline ::RDKit::pbRingInfo* mutable_rings();
  inline ::RDKit::pbRingInfo* release_rings();
  
  // repeated .RDKit.pbConformer conformer = 15;
  inline int conformer_size() const;
  inline void clear_conformer();
  static const int kConformerFieldNumber = 15;
  inline const ::RDKit::pbConformer& conformer(int index) const;
  inline ::RDKit::pbConformer* mutable_conformer(int index);
  inline ::RDKit::pbConformer* add_conformer();
  inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbConformer >&
      conformer() const;
  inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbConformer >*
      mutable_conformer();
  
  // @@protoc_insertion_point(class_scope:RDKit.pbMol)
 private:
  inline void set_has_rings();
  inline void clear_has_rings();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::RDKit::pbAtom > atom_;
  ::google::protobuf::RepeatedPtrField< ::RDKit::pbBond > bond_;
  ::RDKit::pbRingInfo* rings_;
  ::google::protobuf::RepeatedPtrField< ::RDKit::pbConformer > conformer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Mol_2eproto();
  friend void protobuf_AssignDesc_Mol_2eproto();
  friend void protobuf_ShutdownFile_Mol_2eproto();
  
  void InitAsDefaultInstance();
  static pbMol* default_instance_;
};
// ===================================================================


// ===================================================================

// pbAtom

// optional uint32 atomicNum = 1 [default = 6];
inline bool pbAtom::has_atomicnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbAtom::set_has_atomicnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbAtom::clear_has_atomicnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbAtom::clear_atomicnum() {
  atomicnum_ = 6u;
  clear_has_atomicnum();
}
inline ::google::protobuf::uint32 pbAtom::atomicnum() const {
  return atomicnum_;
}
inline void pbAtom::set_atomicnum(::google::protobuf::uint32 value) {
  set_has_atomicnum();
  atomicnum_ = value;
}

// optional bool aromatic = 20;
inline bool pbAtom::has_aromatic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbAtom::set_has_aromatic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbAtom::clear_has_aromatic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbAtom::clear_aromatic() {
  aromatic_ = false;
  clear_has_aromatic();
}
inline bool pbAtom::aromatic() const {
  return aromatic_;
}
inline void pbAtom::set_aromatic(bool value) {
  set_has_aromatic();
  aromatic_ = value;
}

// optional bool noimplicit = 21;
inline bool pbAtom::has_noimplicit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbAtom::set_has_noimplicit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbAtom::clear_has_noimplicit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbAtom::clear_noimplicit() {
  noimplicit_ = false;
  clear_has_noimplicit();
}
inline bool pbAtom::noimplicit() const {
  return noimplicit_;
}
inline void pbAtom::set_noimplicit(bool value) {
  set_has_noimplicit();
  noimplicit_ = value;
}

// optional float mass = 100;
inline bool pbAtom::has_mass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbAtom::set_has_mass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbAtom::clear_has_mass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbAtom::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float pbAtom::mass() const {
  return mass_;
}
inline void pbAtom::set_mass(float value) {
  set_has_mass();
  mass_ = value;
}

// optional sint32 charge = 101;
inline bool pbAtom::has_charge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbAtom::set_has_charge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbAtom::clear_has_charge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbAtom::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline ::google::protobuf::int32 pbAtom::charge() const {
  return charge_;
}
inline void pbAtom::set_charge(::google::protobuf::int32 value) {
  set_has_charge();
  charge_ = value;
}

// optional int32 chiraltag = 102;
inline bool pbAtom::has_chiraltag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbAtom::set_has_chiraltag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbAtom::clear_has_chiraltag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbAtom::clear_chiraltag() {
  chiraltag_ = 0;
  clear_has_chiraltag();
}
inline ::google::protobuf::int32 pbAtom::chiraltag() const {
  return chiraltag_;
}
inline void pbAtom::set_chiraltag(::google::protobuf::int32 value) {
  set_has_chiraltag();
  chiraltag_ = value;
}

// optional int32 hybridization = 103 [default = 4];
inline bool pbAtom::has_hybridization() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbAtom::set_has_hybridization() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbAtom::clear_has_hybridization() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbAtom::clear_hybridization() {
  hybridization_ = 4;
  clear_has_hybridization();
}
inline ::google::protobuf::int32 pbAtom::hybridization() const {
  return hybridization_;
}
inline void pbAtom::set_hybridization(::google::protobuf::int32 value) {
  set_has_hybridization();
  hybridization_ = value;
}

// optional int32 numexpliciths = 104;
inline bool pbAtom::has_numexpliciths() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbAtom::set_has_numexpliciths() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbAtom::clear_has_numexpliciths() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbAtom::clear_numexpliciths() {
  numexpliciths_ = 0;
  clear_has_numexpliciths();
}
inline ::google::protobuf::int32 pbAtom::numexpliciths() const {
  return numexpliciths_;
}
inline void pbAtom::set_numexpliciths(::google::protobuf::int32 value) {
  set_has_numexpliciths();
  numexpliciths_ = value;
}

// optional int32 explicitvalence = 105;
inline bool pbAtom::has_explicitvalence() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbAtom::set_has_explicitvalence() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbAtom::clear_has_explicitvalence() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbAtom::clear_explicitvalence() {
  explicitvalence_ = 0;
  clear_has_explicitvalence();
}
inline ::google::protobuf::int32 pbAtom::explicitvalence() const {
  return explicitvalence_;
}
inline void pbAtom::set_explicitvalence(::google::protobuf::int32 value) {
  set_has_explicitvalence();
  explicitvalence_ = value;
}

// optional int32 implicitvalence = 106;
inline bool pbAtom::has_implicitvalence() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbAtom::set_has_implicitvalence() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbAtom::clear_has_implicitvalence() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbAtom::clear_implicitvalence() {
  implicitvalence_ = 0;
  clear_has_implicitvalence();
}
inline ::google::protobuf::int32 pbAtom::implicitvalence() const {
  return implicitvalence_;
}
inline void pbAtom::set_implicitvalence(::google::protobuf::int32 value) {
  set_has_implicitvalence();
  implicitvalence_ = value;
}

// optional int32 numradicalelectrons = 107;
inline bool pbAtom::has_numradicalelectrons() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbAtom::set_has_numradicalelectrons() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbAtom::clear_has_numradicalelectrons() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbAtom::clear_numradicalelectrons() {
  numradicalelectrons_ = 0;
  clear_has_numradicalelectrons();
}
inline ::google::protobuf::int32 pbAtom::numradicalelectrons() const {
  return numradicalelectrons_;
}
inline void pbAtom::set_numradicalelectrons(::google::protobuf::int32 value) {
  set_has_numradicalelectrons();
  numradicalelectrons_ = value;
}

// optional bool hasatommapnumber = 108;
inline bool pbAtom::has_hasatommapnumber() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pbAtom::set_has_hasatommapnumber() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pbAtom::clear_has_hasatommapnumber() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pbAtom::clear_hasatommapnumber() {
  hasatommapnumber_ = false;
  clear_has_hasatommapnumber();
}
inline bool pbAtom::hasatommapnumber() const {
  return hasatommapnumber_;
}
inline void pbAtom::set_hasatommapnumber(bool value) {
  set_has_hasatommapnumber();
  hasatommapnumber_ = value;
}

// optional int32 molatommapnumber = 109;
inline bool pbAtom::has_molatommapnumber() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void pbAtom::set_has_molatommapnumber() {
  _has_bits_[0] |= 0x00001000u;
}
inline void pbAtom::clear_has_molatommapnumber() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void pbAtom::clear_molatommapnumber() {
  molatommapnumber_ = 0;
  clear_has_molatommapnumber();
}
inline ::google::protobuf::int32 pbAtom::molatommapnumber() const {
  return molatommapnumber_;
}
inline void pbAtom::set_molatommapnumber(::google::protobuf::int32 value) {
  set_has_molatommapnumber();
  molatommapnumber_ = value;
}

// optional bool hasquery = 200;
inline bool pbAtom::has_hasquery() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void pbAtom::set_has_hasquery() {
  _has_bits_[0] |= 0x00002000u;
}
inline void pbAtom::clear_has_hasquery() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void pbAtom::clear_hasquery() {
  hasquery_ = false;
  clear_has_hasquery();
}
inline bool pbAtom::hasquery() const {
  return hasquery_;
}
inline void pbAtom::set_hasquery(bool value) {
  set_has_hasquery();
  hasquery_ = value;
}

// optional .RDKit.pbQuery query = 201;
inline bool pbAtom::has_query() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void pbAtom::set_has_query() {
  _has_bits_[0] |= 0x00004000u;
}
inline void pbAtom::clear_has_query() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void pbAtom::clear_query() {
  if (query_ != NULL) query_->::RDKit::pbQuery::Clear();
  clear_has_query();
}
inline const ::RDKit::pbQuery& pbAtom::query() const {
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::RDKit::pbQuery* pbAtom::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::RDKit::pbQuery;
  return query_;
}
inline ::RDKit::pbQuery* pbAtom::release_query() {
  clear_has_query();
  ::RDKit::pbQuery* temp = query_;
  query_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// pbBond

// required uint32 beginatom = 1;
inline bool pbBond::has_beginatom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbBond::set_has_beginatom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbBond::clear_has_beginatom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbBond::clear_beginatom() {
  beginatom_ = 0u;
  clear_has_beginatom();
}
inline ::google::protobuf::uint32 pbBond::beginatom() const {
  return beginatom_;
}
inline void pbBond::set_beginatom(::google::protobuf::uint32 value) {
  set_has_beginatom();
  beginatom_ = value;
}

// required uint32 endatom = 2;
inline bool pbBond::has_endatom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbBond::set_has_endatom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbBond::clear_has_endatom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbBond::clear_endatom() {
  endatom_ = 0u;
  clear_has_endatom();
}
inline ::google::protobuf::uint32 pbBond::endatom() const {
  return endatom_;
}
inline void pbBond::set_endatom(::google::protobuf::uint32 value) {
  set_has_endatom();
  endatom_ = value;
}

// optional bool aromatic = 20;
inline bool pbBond::has_aromatic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbBond::set_has_aromatic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbBond::clear_has_aromatic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbBond::clear_aromatic() {
  aromatic_ = false;
  clear_has_aromatic();
}
inline bool pbBond::aromatic() const {
  return aromatic_;
}
inline void pbBond::set_aromatic(bool value) {
  set_has_aromatic();
  aromatic_ = value;
}

// optional bool conjugated = 21;
inline bool pbBond::has_conjugated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbBond::set_has_conjugated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbBond::clear_has_conjugated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbBond::clear_conjugated() {
  conjugated_ = false;
  clear_has_conjugated();
}
inline bool pbBond::conjugated() const {
  return conjugated_;
}
inline void pbBond::set_conjugated(bool value) {
  set_has_conjugated();
  conjugated_ = value;
}

// optional uint32 type = 102 [default = 1];
inline bool pbBond::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbBond::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbBond::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbBond::clear_type() {
  type_ = 1u;
  clear_has_type();
}
inline ::google::protobuf::uint32 pbBond::type() const {
  return type_;
}
inline void pbBond::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 dir = 103;
inline bool pbBond::has_dir() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbBond::set_has_dir() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbBond::clear_has_dir() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbBond::clear_dir() {
  dir_ = 0u;
  clear_has_dir();
}
inline ::google::protobuf::uint32 pbBond::dir() const {
  return dir_;
}
inline void pbBond::set_dir(::google::protobuf::uint32 value) {
  set_has_dir();
  dir_ = value;
}

// optional uint32 stereo = 104;
inline bool pbBond::has_stereo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbBond::set_has_stereo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbBond::clear_has_stereo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbBond::clear_stereo() {
  stereo_ = 0u;
  clear_has_stereo();
}
inline ::google::protobuf::uint32 pbBond::stereo() const {
  return stereo_;
}
inline void pbBond::set_stereo(::google::protobuf::uint32 value) {
  set_has_stereo();
  stereo_ = value;
}

// repeated uint32 stereoatom = 105;
inline int pbBond::stereoatom_size() const {
  return stereoatom_.size();
}
inline void pbBond::clear_stereoatom() {
  stereoatom_.Clear();
}
inline ::google::protobuf::uint32 pbBond::stereoatom(int index) const {
  return stereoatom_.Get(index);
}
inline void pbBond::set_stereoatom(int index, ::google::protobuf::uint32 value) {
  stereoatom_.Set(index, value);
}
inline void pbBond::add_stereoatom(::google::protobuf::uint32 value) {
  stereoatom_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
pbBond::stereoatom() const {
  return stereoatom_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
pbBond::mutable_stereoatom() {
  return &stereoatom_;
}

// optional bool hasquery = 200;
inline bool pbBond::has_hasquery() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbBond::set_has_hasquery() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbBond::clear_has_hasquery() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbBond::clear_hasquery() {
  hasquery_ = false;
  clear_has_hasquery();
}
inline bool pbBond::hasquery() const {
  return hasquery_;
}
inline void pbBond::set_hasquery(bool value) {
  set_has_hasquery();
  hasquery_ = value;
}

// optional .RDKit.pbQuery query = 201;
inline bool pbBond::has_query() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbBond::set_has_query() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbBond::clear_has_query() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbBond::clear_query() {
  if (query_ != NULL) query_->::RDKit::pbQuery::Clear();
  clear_has_query();
}
inline const ::RDKit::pbQuery& pbBond::query() const {
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::RDKit::pbQuery* pbBond::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::RDKit::pbQuery;
  return query_;
}
inline ::RDKit::pbQuery* pbBond::release_query() {
  clear_has_query();
  ::RDKit::pbQuery* temp = query_;
  query_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// pbUIntVect

// repeated uint32 val = 1;
inline int pbUIntVect::val_size() const {
  return val_.size();
}
inline void pbUIntVect::clear_val() {
  val_.Clear();
}
inline ::google::protobuf::uint32 pbUIntVect::val(int index) const {
  return val_.Get(index);
}
inline void pbUIntVect::set_val(int index, ::google::protobuf::uint32 value) {
  val_.Set(index, value);
}
inline void pbUIntVect::add_val(::google::protobuf::uint32 value) {
  val_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
pbUIntVect::val() const {
  return val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
pbUIntVect::mutable_val() {
  return &val_;
}

// -------------------------------------------------------------------

// pbRingInfo

// repeated .RDKit.pbUIntVect bondring = 1;
inline int pbRingInfo::bondring_size() const {
  return bondring_.size();
}
inline void pbRingInfo::clear_bondring() {
  bondring_.Clear();
}
inline const ::RDKit::pbUIntVect& pbRingInfo::bondring(int index) const {
  return bondring_.Get(index);
}
inline ::RDKit::pbUIntVect* pbRingInfo::mutable_bondring(int index) {
  return bondring_.Mutable(index);
}
inline ::RDKit::pbUIntVect* pbRingInfo::add_bondring() {
  return bondring_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >&
pbRingInfo::bondring() const {
  return bondring_;
}
inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >*
pbRingInfo::mutable_bondring() {
  return &bondring_;
}

// repeated .RDKit.pbUIntVect atomring = 2;
inline int pbRingInfo::atomring_size() const {
  return atomring_.size();
}
inline void pbRingInfo::clear_atomring() {
  atomring_.Clear();
}
inline const ::RDKit::pbUIntVect& pbRingInfo::atomring(int index) const {
  return atomring_.Get(index);
}
inline ::RDKit::pbUIntVect* pbRingInfo::mutable_atomring(int index) {
  return atomring_.Mutable(index);
}
inline ::RDKit::pbUIntVect* pbRingInfo::add_atomring() {
  return atomring_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >&
pbRingInfo::atomring() const {
  return atomring_;
}
inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbUIntVect >*
pbRingInfo::mutable_atomring() {
  return &atomring_;
}

// -------------------------------------------------------------------

// pbPoint3D

// optional float x = 1;
inline bool pbPoint3D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbPoint3D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbPoint3D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbPoint3D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float pbPoint3D::x() const {
  return x_;
}
inline void pbPoint3D::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool pbPoint3D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbPoint3D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbPoint3D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbPoint3D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float pbPoint3D::y() const {
  return y_;
}
inline void pbPoint3D::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 3;
inline bool pbPoint3D::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbPoint3D::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbPoint3D::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbPoint3D::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float pbPoint3D::z() const {
  return z_;
}
inline void pbPoint3D::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// pbConformer

// required uint32 id = 1;
inline bool pbConformer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbConformer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbConformer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbConformer::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 pbConformer::id() const {
  return id_;
}
inline void pbConformer::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional bool is3d = 2;
inline bool pbConformer::has_is3d() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbConformer::set_has_is3d() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbConformer::clear_has_is3d() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbConformer::clear_is3d() {
  is3d_ = false;
  clear_has_is3d();
}
inline bool pbConformer::is3d() const {
  return is3d_;
}
inline void pbConformer::set_is3d(bool value) {
  set_has_is3d();
  is3d_ = value;
}

// repeated .RDKit.pbPoint3D position = 3;
inline int pbConformer::position_size() const {
  return position_.size();
}
inline void pbConformer::clear_position() {
  position_.Clear();
}
inline const ::RDKit::pbPoint3D& pbConformer::position(int index) const {
  return position_.Get(index);
}
inline ::RDKit::pbPoint3D* pbConformer::mutable_position(int index) {
  return position_.Mutable(index);
}
inline ::RDKit::pbPoint3D* pbConformer::add_position() {
  return position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbPoint3D >&
pbConformer::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbPoint3D >*
pbConformer::mutable_position() {
  return &position_;
}

// -------------------------------------------------------------------

// pbQuery

// required uint32 type = 1;
inline bool pbQuery::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbQuery::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbQuery::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbQuery::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 pbQuery::type() const {
  return type_;
}
inline void pbQuery::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required string description = 2;
inline bool pbQuery::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbQuery::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbQuery::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbQuery::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& pbQuery::description() const {
  return *description_;
}
inline void pbQuery::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void pbQuery::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void pbQuery::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbQuery::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* pbQuery::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool negation = 3;
inline bool pbQuery::has_negation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbQuery::set_has_negation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbQuery::clear_has_negation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbQuery::clear_negation() {
  negation_ = false;
  clear_has_negation();
}
inline bool pbQuery::negation() const {
  return negation_;
}
inline void pbQuery::set_negation(bool value) {
  set_has_negation();
  negation_ = value;
}

// repeated sint32 intvalue = 20;
inline int pbQuery::intvalue_size() const {
  return intvalue_.size();
}
inline void pbQuery::clear_intvalue() {
  intvalue_.Clear();
}
inline ::google::protobuf::int32 pbQuery::intvalue(int index) const {
  return intvalue_.Get(index);
}
inline void pbQuery::set_intvalue(int index, ::google::protobuf::int32 value) {
  intvalue_.Set(index, value);
}
inline void pbQuery::add_intvalue(::google::protobuf::int32 value) {
  intvalue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
pbQuery::intvalue() const {
  return intvalue_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
pbQuery::mutable_intvalue() {
  return &intvalue_;
}

// optional sint32 inttol = 21;
inline bool pbQuery::has_inttol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbQuery::set_has_inttol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbQuery::clear_has_inttol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbQuery::clear_inttol() {
  inttol_ = 0;
  clear_has_inttol();
}
inline ::google::protobuf::int32 pbQuery::inttol() const {
  return inttol_;
}
inline void pbQuery::set_inttol(::google::protobuf::int32 value) {
  set_has_inttol();
  inttol_ = value;
}

// optional sint32 intbegin = 22;
inline bool pbQuery::has_intbegin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbQuery::set_has_intbegin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbQuery::clear_has_intbegin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbQuery::clear_intbegin() {
  intbegin_ = 0;
  clear_has_intbegin();
}
inline ::google::protobuf::int32 pbQuery::intbegin() const {
  return intbegin_;
}
inline void pbQuery::set_intbegin(::google::protobuf::int32 value) {
  set_has_intbegin();
  intbegin_ = value;
}

// optional sint32 intend = 23;
inline bool pbQuery::has_intend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbQuery::set_has_intend() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbQuery::clear_has_intend() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbQuery::clear_intend() {
  intend_ = 0;
  clear_has_intend();
}
inline ::google::protobuf::int32 pbQuery::intend() const {
  return intend_;
}
inline void pbQuery::set_intend(::google::protobuf::int32 value) {
  set_has_intend();
  intend_ = value;
}

// optional bool openbegin = 24;
inline bool pbQuery::has_openbegin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbQuery::set_has_openbegin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbQuery::clear_has_openbegin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbQuery::clear_openbegin() {
  openbegin_ = false;
  clear_has_openbegin();
}
inline bool pbQuery::openbegin() const {
  return openbegin_;
}
inline void pbQuery::set_openbegin(bool value) {
  set_has_openbegin();
  openbegin_ = value;
}

// optional bool openend = 25;
inline bool pbQuery::has_openend() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbQuery::set_has_openend() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbQuery::clear_has_openend() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbQuery::clear_openend() {
  openend_ = false;
  clear_has_openend();
}
inline bool pbQuery::openend() const {
  return openend_;
}
inline void pbQuery::set_openend(bool value) {
  set_has_openend();
  openend_ = value;
}

// optional .RDKit.pbMol molvalue = 26;
inline bool pbQuery::has_molvalue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbQuery::set_has_molvalue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbQuery::clear_has_molvalue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbQuery::clear_molvalue() {
  if (molvalue_ != NULL) molvalue_->::RDKit::pbMol::Clear();
  clear_has_molvalue();
}
inline const ::RDKit::pbMol& pbQuery::molvalue() const {
  return molvalue_ != NULL ? *molvalue_ : *default_instance_->molvalue_;
}
inline ::RDKit::pbMol* pbQuery::mutable_molvalue() {
  set_has_molvalue();
  if (molvalue_ == NULL) molvalue_ = new ::RDKit::pbMol;
  return molvalue_;
}
inline ::RDKit::pbMol* pbQuery::release_molvalue() {
  clear_has_molvalue();
  ::RDKit::pbMol* temp = molvalue_;
  molvalue_ = NULL;
  return temp;
}

// repeated .RDKit.pbQuery child = 5;
inline int pbQuery::child_size() const {
  return child_.size();
}
inline void pbQuery::clear_child() {
  child_.Clear();
}
inline const ::RDKit::pbQuery& pbQuery::child(int index) const {
  return child_.Get(index);
}
inline ::RDKit::pbQuery* pbQuery::mutable_child(int index) {
  return child_.Mutable(index);
}
inline ::RDKit::pbQuery* pbQuery::add_child() {
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbQuery >&
pbQuery::child() const {
  return child_;
}
inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbQuery >*
pbQuery::mutable_child() {
  return &child_;
}

// -------------------------------------------------------------------

// pbMol

// repeated .RDKit.pbAtom atom = 1;
inline int pbMol::atom_size() const {
  return atom_.size();
}
inline void pbMol::clear_atom() {
  atom_.Clear();
}
inline const ::RDKit::pbAtom& pbMol::atom(int index) const {
  return atom_.Get(index);
}
inline ::RDKit::pbAtom* pbMol::mutable_atom(int index) {
  return atom_.Mutable(index);
}
inline ::RDKit::pbAtom* pbMol::add_atom() {
  return atom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbAtom >&
pbMol::atom() const {
  return atom_;
}
inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbAtom >*
pbMol::mutable_atom() {
  return &atom_;
}

// repeated .RDKit.pbBond bond = 2;
inline int pbMol::bond_size() const {
  return bond_.size();
}
inline void pbMol::clear_bond() {
  bond_.Clear();
}
inline const ::RDKit::pbBond& pbMol::bond(int index) const {
  return bond_.Get(index);
}
inline ::RDKit::pbBond* pbMol::mutable_bond(int index) {
  return bond_.Mutable(index);
}
inline ::RDKit::pbBond* pbMol::add_bond() {
  return bond_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbBond >&
pbMol::bond() const {
  return bond_;
}
inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbBond >*
pbMol::mutable_bond() {
  return &bond_;
}

// optional .RDKit.pbRingInfo rings = 100;
inline bool pbMol::has_rings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbMol::set_has_rings() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbMol::clear_has_rings() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbMol::clear_rings() {
  if (rings_ != NULL) rings_->::RDKit::pbRingInfo::Clear();
  clear_has_rings();
}
inline const ::RDKit::pbRingInfo& pbMol::rings() const {
  return rings_ != NULL ? *rings_ : *default_instance_->rings_;
}
inline ::RDKit::pbRingInfo* pbMol::mutable_rings() {
  set_has_rings();
  if (rings_ == NULL) rings_ = new ::RDKit::pbRingInfo;
  return rings_;
}
inline ::RDKit::pbRingInfo* pbMol::release_rings() {
  clear_has_rings();
  ::RDKit::pbRingInfo* temp = rings_;
  rings_ = NULL;
  return temp;
}

// repeated .RDKit.pbConformer conformer = 15;
inline int pbMol::conformer_size() const {
  return conformer_.size();
}
inline void pbMol::clear_conformer() {
  conformer_.Clear();
}
inline const ::RDKit::pbConformer& pbMol::conformer(int index) const {
  return conformer_.Get(index);
}
inline ::RDKit::pbConformer* pbMol::mutable_conformer(int index) {
  return conformer_.Mutable(index);
}
inline ::RDKit::pbConformer* pbMol::add_conformer() {
  return conformer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RDKit::pbConformer >&
pbMol::conformer() const {
  return conformer_;
}
inline ::google::protobuf::RepeatedPtrField< ::RDKit::pbConformer >*
pbMol::mutable_conformer() {
  return &conformer_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RDKit

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Mol_2eproto__INCLUDED
